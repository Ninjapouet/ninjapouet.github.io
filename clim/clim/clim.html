<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>clim (clim.clim)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="index.html">Up</a> â€“ <a href="index.html">clim</a> &#x00BB; clim</nav><h1 id="clim"><a href="#clim" class="anchor"></a>Clim</h1><p><a href="Clim/index.html"><code>Clim</code></a> stands for Command Line Interface Maker and helps making clean and nice command line interfaces for your binaries.</p><p>There are various ways of building CLI in OCaml. The most obvious one is using the <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Arg.html">Arg</a> module from the standard library. While this modules does the job, the result is quite basic and not as nice as one would expect from modern binaries.</p><p>There are other libraries that help but the most effective in this job is probably <a href="https://erratique.ch/software/cmdliner/doc/Cmdliner">Cmdliner</a> which provides a rich and nice API for builing CLIs. However, <a href="https://erratique.ch/software/cmdliner/doc/Cmdliner">Cmdliner</a>'s API isn't very user friendly for it needs to define several intermediate values which introduce noise in the binary source code. Furthermore, the library doesn't suit well for CLI composition which happens quite often in my own programming experience.</p><p>The <a href="Clim/index.html"><code>Clim</code></a> library provides some layout above <a href="https://erratique.ch/software/cmdliner/doc/Cmdliner">Cmdliner</a> to simplify the latter usage. With it, there are mainly two ways of defining CLI: an incremental one and a object-oriented one.</p><nav class="toc"><ul><li><a href="#incremental-cli">Incremental CLI</a><ul><li><a href="#configuration">Configuration</a></li><li><a href="#arguments">Arguments</a></li><li><a href="#commands">Commands</a></li><li><a href="#inheritance">Inheritance</a></li><li><a href="#lwt">Lwt</a></li></ul></li><li><a href="#object-oriented-cli">Object-oriented CLI</a><ul><li><a href="#definition">Definition</a></li><li><a href="#overloading">Overloading</a></li><li><a href="#execution">Execution</a></li></ul></li></ul></nav></header><h2 id="incremental-cli"><a href="#incremental-cli" class="anchor"></a>Incremental CLI</h2><p>The incremental way allows the user to define its CLI along its code with few functions inherited from <a href="https://erratique.ch/software/cmdliner/doc/Cmdliner">Cmdliner</a>. It uses three concepts : the <em>configuration</em>, the <em>argument</em> and the <em>command</em>.</p><h3 id="configuration"><a href="#configuration" class="anchor"></a>Configuration</h3><p>A CLI is basically stored in a configuration which may be constructed very simply by:</p><pre><code class="ml">open Clim

let cfg = create ()</code></pre><p>With <a href="Clim/index.html"><code>Clim</code></a> binaries are constructed from such a configuration.</p><h3 id="arguments"><a href="#arguments" class="anchor"></a>Arguments</h3><p>Now arguments are specified by using functions deriving directly from <a href="https://erratique.ch/software/cmdliner/doc/Cmdliner">Cmdliner</a> but in a more concise way to avoid intermediate object construction.</p><p>For example, the following code:</p><pre><code class="ml">let foo = register cfg @@ value @@ opt
  ~doc:&quot;Foo parameter&quot;
  string
  &quot;foo&quot;
  [&quot;f&quot;; &quot;foo&quot;]</code></pre><p>will add a optional string parameter <code>foo</code> with a default value <code>&quot;foo&quot;</code> which will be customizable through the CLI with options <code>-f</code> or <code>--foo</code>. The main difference with <code>Cmdliner</code> is the <code>register</code> function which adds the parameter to <code>cfg</code> and returns a function whose type is <code>unit -&gt; 'a</code> where <code>'a</code> depends on the given type specification. Here, <code>foo</code> is a <code>unit -&gt; string</code> function and is a getter to the foo parameter value.</p><p>Any function using <code>foo</code> underlying value can use it by calling it:</p><pre><code class="ml">let main () = Format.printf &quot;foo = %s@.&quot; (foo ())</code></pre><h3 id="commands"><a href="#commands" class="anchor"></a>Commands</h3><p>When all arguments are defined, the final CLI can be defined using the <code>command</code> function:</p><pre><code class="ml">let foo_cmd = command ~cfg ~doc:&quot;Foo printing.&quot; main</code></pre><p>which accepts several optional arguments customizing the resulting <code>man</code> page.</p><p>To execute this command, you must use the run function:</p><pre><code class="ml">let () = run foo_cmd</code></pre><p>and that's all. The resulting binary will respond to <code>--help</code> or other CLI options automatically and give a nice looking <code>man</code> page.</p><h3 id="inheritance"><a href="#inheritance" class="anchor"></a>Inheritance</h3><p>With the configuration system, it's possible (and encouraged) to share configuration between binaries in order to simplify the code but also give related binaries a sound CLI.</p><p>When releasing a binary package, just expose its configuration and command so that related binaries designed to extend the previous one can inherit them with:</p><pre><code class="ml">(* extending the previous configuration *)
   let ext_cfg = from cfg</code></pre><p>That way, we can add the <code>bar</code> option:</p><pre><code class="ml">let bar = register ext_cfg @@ value @@ opt
    ~doc:&quot;Bar parameter&quot;
    int
    0
    [&quot;b&quot;; &quot;bar&quot;]</code></pre><p>and even change the CLI behavior:</p><pre><code class="ml">let bar_cmd = {
  foo_cmd with
  cmd = (fun () -&gt;
      foo_cmd.cmd ();
      let b = bar () in
      Format.printf &quot;square(bar) = %i@.&quot; (b * b));
  doc = foo_cmd ^ &quot; Prints also the square of bar parameter.&quot;;
}
let () = run bar_cmd</code></pre><p>As you can see, running the binary will print the <code>foo</code> value but also the square of <code>bar</code>.</p><h3 id="lwt"><a href="#lwt" class="anchor"></a>Lwt</h3><p><code>Clim</code> is fully compatible with Lwt. Simply give a Lwt thread to <code>command</code> to produce a <code>'a Lwt.t command</code> value. Running this command will produce a <code>'a Lwt.t</code> value that should be passed to <code>Lwt_main.run</code>.</p><h2 id="object-oriented-cli"><a href="#object-oriented-cli" class="anchor"></a>Object-oriented CLI</h2><p>While the incremental CLI definition works well for new binaries, it suits not well for existing ones as the migration from any old system to this one will likely need a complete rewriting of the CLI definition. For example, a binary wrote with <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Arg.html">Arg</a> isn't easily converted to the incremental CLI definition as the former is a centralized definition design which likely appears in the final binary source file. Furthermore, it uses some kind of continuation style while the incremental definition simply gives accessors.</p><p>The object-oriented CLI definition is somehow a merge between the incremental CLI definition, the centralized design with continuations and a Python <code>argparse</code> like usage. The resulting API benefits from the three systems and is very recomended for your CLI definitions.</p><h3 id="definition"><a href="#definition" class="anchor"></a>Definition</h3><p>To define an object-oriented CLI : simply inherit from <a href="Clim/class-cli/index.html"><code>Clim.cli</code></a> and define the entrypoint method (equivalent to the command definition) and add arguments in the initalizer using the <a href="Clim/class-cli/index.html#method-arg"><code>Clim.cli.arg</code></a> or <a href="Clim/class-cli/index.html#method-set"><code>Clim.cli.set</code></a> methods.</p><pre><code class="ml">class foo = object(self)
  inherit [_] cli
  val mutable who = &quot;world&quot;
  method entrypoint () = Format.printf &quot;Hello %s!@.&quot; who
  initializer
    self#add (value @@ opt string who ~doc:&quot;Someone&quot; [&quot;w&quot;; &quot;who&quot;]) (fun w -&gt; who &lt;- w)
end</code></pre><p>The command is fully customizable by defining or overloading the appropriate methods. If you write a generic application which will likely be extended, use a class or simply an direct OCaml object else.</p><h3 id="overloading"><a href="#overloading" class="anchor"></a>Overloading</h3><p>Obviously, inheriting will do the job:</p><pre><code class="ml">class bar = object(self)
  inherit foo as super
  val mutable from = &quot;Paris&quot;
  method! entrypoint () = super#entrypoint (); Format.printf &quot;(from %s)@.&quot; from
  initializer
    self#add (value @@ opt string who ~doc:&quot;Where&quot; [&quot;f&quot;; &quot;from&quot;]) (fun f -&gt; from &lt;- f)
end</code></pre><h3 id="execution"><a href="#execution" class="anchor"></a>Execution</h3><p>Simply call the <a href="Clim/class-cli/index.html#method-run"><code>Clim.cli.run</code></a> method to run the underlying command:</p><pre><code class="ml">let _ = bar#run</code></pre><p>As for the incremental API, <code>Lwt</code> is fully supported by giving the result to <code>Lwt_main.run</code></p></div></body></html>