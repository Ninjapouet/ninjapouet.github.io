<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Slurp_cohttp__Server (slurp-cohttp.Slurp_cohttp__Server)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">slurp-cohttp</a> &#x00BB; Slurp_cohttp__Server</nav><h1>Module <code>Slurp_cohttp__Server</code></h1><p>Slurp Cohttp server definitions.</p><h2 id="quickstart"><a href="#quickstart" class="anchor"></a>Quickstart</h2><p>To use slurp with the cohttp backend, you can simply call the <code>slurp-cohttp.server</code> binary coming with the package. However, if you need to tune the server implementation, you can use the server extensible definition.</p><h2 id="extension"><a href="#extension" class="anchor"></a>Extension</h2><p>Most of the time, the server is launched together with other services that may already bind the slurp default option names. To avoid any conflict, the server comes with a functorial definition based on option names. The parameters names are defined with string lists following the <a href="https://erratique.ch/logiciel/cmdliner">Cmdliner</a> convention: short names are one char strings and others strings are long names. For example, if you want to rename the &quot;--port&quot; option, simply reinstanciate the server definition with a custom configuration:</p><pre><code class="ml">open Slurp_cohttp

module My_configuration = struct
  let port = [&quot;my-port&quot;]
  let service = Default.service
end

module My_server = Make(My_configuration)

let _ = Ezcmdliner.run My_server.command</code></pre><p>the other extension oftenly used is adding new options for various services added with the custom REST API. Adding options is allowed by the <a href="https://github.com/Ninjapouet/ezcmdliner">Ezcmdliner</a> interface. For example, we can add the option <code>foo</code> simply by registering it with:</p><pre><code class="ml">let foo = Ezcmdliner.(
    register My_server.cfg @@ value @@ opt
      ~doc:&quot;My awesome option&quot;
      int
      42
      [&quot;foo&quot;])</code></pre><p><code>foo ()</code> will then return the <code>foo</code> option value at runtime.</p><p>More subtle extensions are also available by redefining the <code>My_server.command</code> value to add some custom behavior to the resulting binary. For example:</p><pre><code class="ml">let command = Ezcmdliner.({
    My_server.command with
    cmd = fun () -&gt; Lwt.join [
        My_server.command.cmd (); (* Legacy server commmand *)
        (fun () -&gt; print_endline &quot;Hello there!&quot;; Lwt.return_unit);
    ];
  })</code></pre><p>will add the trace &quot;Hello there!&quot; on server run.</p><h2 id="api"><a href="#api" class="anchor"></a>API</h2><nav class="toc"><ul><li><a href="#interface">Interface</a></li><li><a href="#default-implementation">Default implementation</a></li></ul></nav></header><dl><dt class="spec module-type" id="module-type-CFG"><a href="#module-type-CFG" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-CFG/index.html">CFG</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Command line parameter names.</p></dd></dl><section><header><h3 id="interface"><a href="#interface" class="anchor"></a>Interface</h3><p>The cohhtp slurp interface is given by <a href="module-type-S/index.html"><code>S</code></a> which give the <code>Ezcmdliner</code> configuration used which allows adding more parameters if needed. It also gives the parameters accessors and an underlying server implementation which, again, is configurable through specific cohttp stuff.</p></header><dl><dt class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The cohttp slurp interface.</p></dd></dl><dl><dt class="spec module" id="module-Default"><a href="#module-Default" class="anchor"></a><code><span class="keyword">module</span> <a href="Default/index.html">Default</a> : <a href="index.html#module-type-CFG">CFG</a></code></dt><dd><p>Default configuration.</p></dd></dl><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-C/index.html">C</a> : <a href="index.html#module-type-CFG">CFG</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a></code></dt><dd><p>Cohttp slurp functor.</p></dd></dl></section><section><header><h2 id="default-implementation"><a href="#default-implementation" class="anchor"></a>Default implementation</h2><p>This library gives a default implementation using the &quot;p&quot; or &quot;port&quot; names for the port option and &quot;s&quot; or &quot;service&quot; for the services option.</p></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="index.html#module-type-S">S</a></code></span></summary><dl><dt class="spec value" id="val-cfg"><a href="#val-cfg" class="anchor"></a><code><span class="keyword">val</span> cfg : Ezcmdliner.cfg</code></dt><dd><p>The <code>Ezcmdliner</code> configuration.</p></dd></dl><dl><dt class="spec value" id="val-port"><a href="#val-port" class="anchor"></a><code><span class="keyword">val</span> port : unit <span>&#45;&gt;</span> int</code></dt><dd><p>Returns the port value.</p></dd></dl><dl><dt class="spec value" id="val-services"><a href="#val-services" class="anchor"></a><code><span class="keyword">val</span> services : unit <span>&#45;&gt;</span> <span>string list</span></code></dt><dd><p>Returns the services to load.</p></dd></dl><dl><dt class="spec value" id="val-server"><a href="#val-server" class="anchor"></a><code><span class="keyword">val</span> server : <span>?&#8288;mode:Conduit_lwt_unix.server</span> <span>&#45;&gt;</span> <span>?&#8288;callback:<span>(Cohttp_lwt_unix.Server.conn <span>&#45;&gt;</span> Cohttp.Request.t <span>&#45;&gt;</span> Cohttp_lwt.Body.t <span>&#45;&gt;</span> <span>Cohttp_lwt_unix.Server.response_action Lwt.t</span>)</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span>unit Lwt.t</span></code></dt><dd><p><code>server ~mode ~callback ()</code> launches the cohttp slurp server using the <code>Conduit</code> mode <code>mode</code>. <code>callback</code> is used to overwrite the default slurp behavior to handle some corner case. If <code>callback</code> raises some exception, the default slurp behavior is used.</p></dd></dl><dl><dt class="spec value" id="val-command"><a href="#val-command" class="anchor"></a><code><span class="keyword">val</span> command : <span><span>unit Lwt.t</span> Ezcmdliner.command</span></code></dt><dd><p>The slurp cohttp command specification.</p></dd></dl></details></div></div></div></section></div></body></html>